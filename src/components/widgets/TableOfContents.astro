---
/**
 * TableOfContents Component
 * 
 * Builds a hierarchical table of contents from markdown headings.
 * Assumes H1 is the page title (Obsidian convention) and starts TOC at H2.
 * 
 * Features:
 * - Respects global depth config (tableOfContents.depth)
 * - Handles skipped heading levels gracefully
 * - Type-safe implementation
 * - Immutable data structures
 */

import TableOfContentsHeading from "./TableOfContentsHeading.astro";
import { siteConfig } from "@/site.config";
import type { Heading } from "@/types";

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

// TOC-specific heading with subheadings
interface TocHeading extends Heading {
  subheadings: TocHeading[];
}

/**
 * Build table of contents from flat heading list
 * 
 * @param headings - Flat list of headings from markdown
 * @returns Hierarchical TOC structure starting at H2
 */
function buildToc(headings: Heading[]): TocHeading[] {
  // Validate input
  if (!headings || headings.length === 0) {
    return [];
  }

  // Get max depth from config (default to 6 if not set)
  const maxDepth = siteConfig.tableOfContents?.depth ?? 6;
  const topLevel = 2; // H2 is top level (H1 is page title)

  // Filter headings by depth range
  const validHeadings = headings.filter(
    h => h.depth >= topLevel && h.depth <= maxDepth
  );

  if (validHeadings.length === 0) {
    return [];
  }

  // Build hierarchical structure
  const toc: TocHeading[] = [];
  const stack: TocHeading[] = [];

  for (const h of validHeadings) {
    // Create TOC heading (immutable)
    const tocHeading: TocHeading = {
      ...h,
      subheadings: []
    };

    if (h.depth === topLevel) {
      // Top-level heading (H2)
      toc.push(tocHeading);
      stack.length = 0; // Clear stack
      stack.push(tocHeading);
    } else {
      // Find parent in stack
      // Pop stack until we find a heading at the correct parent depth
      const parentDepth = h.depth - 1;
      
      while (stack.length > 0 && stack[stack.length - 1].depth >= h.depth) {
        stack.pop();
      }

      // Find the closest parent (walk up if needed)
      let parent = stack.length > 0 ? stack[stack.length - 1] : null;
      
      // If no valid parent in stack, try to find one by walking up depths
      if (!parent || parent.depth >= h.depth) {
        // Find the most recent heading that could be a parent
        let searchDepth = h.depth - 1;
        while (searchDepth >= topLevel && !parent) {
          parent = stack.find(s => s.depth === searchDepth) ?? null;
          searchDepth--;
        }
      }

      if (parent && parent.depth < h.depth) {
        // Add to parent's subheadings
        parent.subheadings.push(tocHeading);
        stack.push(tocHeading);
      } else {
        // Orphaned heading or skipped levels - add to top level
        toc.push(tocHeading);
        stack.length = 0;
        stack.push(tocHeading);
      }
    }
  }

  return toc;
}

const toc = buildToc(headings);
const hasToc = toc.length > 0;
---

{hasToc && (
  <details class="animate group rounded-lg border border-ui-primary">
    <summary
      class="cursor-pointer rounded-t-lg px-3 py-1.5 font-medium group-open:bg-surface-raised hover:bg-surface-subtle transition-colors"
    >
      Table of Contents
    </summary>
    <nav class="toc" aria-label="Table of contents">
      <ul class="py-4">
        {toc.map((heading) => (
          <TableOfContentsHeading heading={heading} />
        ))}
      </ul>
    </nav>
  </details>
)}